#!/usr/bin/env python3
"""
header_report.py
Usage:
    python header_report.py header.txt output.pdf

Self-contained:
    - Reads and analyzes the email header
    - Generates a full PDF forensic report
No external scripts needed.
"""

import re
import sys
import os
import socket
from email import policy
from email.parser import BytesParser
import dns.resolver
import whois
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from reportlab.lib.units import mm


IP_RE = r"\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b"


# -------------------------
# DNS, PTR, WHOIS Utilities
# -------------------------

def dns_txt(domain):
    """Fetch TXT records via dnspython."""
    try:
        answers = dns.resolver.resolve(domain, "TXT")
        return "; ".join([txt.to_text().strip('"') for txt in answers])
    except:
        return "N/A"


def ptr_lookup(ip):
    """Reverse DNS lookup."""
    try:
        return socket.gethostbyaddr(ip)[0]
    except:
        return "N/A"


def whois_lookup(ip):
    """WHOIS for IP."""
    try:
        data = whois.whois(ip)
        return f"Org: {data.get('org')} | Country: {data.get('country')}"
    except:
        return "N/A"


# -------------------------
# Parsing Functions
# -------------------------

def load_message(path):
    with open(path, "rb") as f:
        return BytesParser(policy=policy.default).parse(f)


def extract_basic_meta(msg):
    fields = ["From", "To", "Subject", "Date", "Message-ID"]
    return {f: msg.get(f, "N/A") for f in fields}


def extract_received(msg):
    recs = msg.get_all("Received", []) or []
    return list(reversed(recs))  # oldest → newest


def parse_received_line(line):
    ts = line.split(";")[-1].strip() if ";" in line else ""
    ips = re.findall(IP_RE, line)
    helo = "Unknown"
    m = re.search(r"from\s+([^\s\(\;]+)", line)
    if m:
        helo = m.group(1)
    return {"raw": line.strip(), "timestamp": ts, "ips": ips, "helo": helo}


# -------------------------
# Analysis Core
# -------------------------

def run_analysis(path):
    msg = load_message(path)
    meta = extract_basic_meta(msg)
    recs = extract_received(msg)
    parsed = [parse_received_line(r) for r in recs]

    out = []

    out.append("=== BASIC METADATA ===")
    for k, v in meta.items():
        out.append(f"{k}: {v}")

    out.append("\n=== HOP TIMELINE (origin → destination) ===")

    if not parsed:
        out.append("No Received headers found.")
    else:
        for i, hop in enumerate(parsed, 1):
            out.append(f"\nHop {i}:")
            out.append(f" Timestamp: {hop['timestamp']}")
            out.append(f" HELO     : {hop['helo']}")
            out.append(f" IPs      : {', '.join(hop['ips']) if hop['ips'] else 'None'}")

            if hop["ips"]:
                ip = hop["ips"][0]
                out.append(f" PTR      : {ptr_lookup(ip)}")
                out.append(f" WHOIS    : {whois_lookup(ip)}")

    # AUTH
    out.append("\n=== AUTH CHECKS (SPF / DKIM / DMARC) ===")
    frm = meta.get("From", "")
    m = re.search(r"@([A-Za-z0-9\.-]+)", frm)
    domain = m.group(1) if m else None

    if not domain:
        out.append("Could not extract sender domain.")
    else:
        out.append(f"Domain: {domain}")
        out.append(f"SPF TXT: {dns_txt(domain)}")
        out.append(f"DMARC TXT: {dns_txt(f'_dmarc.{domain}')}")

        dkim = msg.get("DKIM-Signature")
        if dkim:
            s = re.search(r"s=([^;]+)", dkim)
            sel = s.group(1) if s else None
            if sel:
                out.append(f"DKIM selector: {sel}")
                out.append(f"DKIM TXT: {dns_txt(f'{sel}._domainkey.{domain}')}")
            else:
                out.append("DKIM present but selector missing.")
        else:
            out.append("No DKIM-Signature header found.")

    out.append("\n=== END ===\n")

    return "\n".join(out)


# -------------------------
# PDF GENERATOR
# -------------------------

def write_pdf(text, out_pdf):
    c = canvas.Canvas(out_pdf, pagesize=A4)
    width, height = A4

    c.setFont("Helvetica-Bold", 18)
    c.drawString(20 * mm, height - 20 * mm, "Email Header Forensic Report")

    c.setFont("Helvetica", 12)
    c.drawString(20 * mm, height - 30 * mm, "Generated by Automated Analyzer")

    c.setFont("Courier", 9)
    y = height - 45 * mm
    line_height = 4.5 * mm

    for line in text.split("\n"):
        if y < 20 * mm:
            c.showPage()
            c.setFont("Courier", 9)
            y = height - 20 * mm

        c.drawString(20 * mm, y, line)
        y -= line_height

    c.save()


# -------------------------
# Main
# -------------------------

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python header_report.py header.txt output.pdf")
        sys.exit(1)

    header_file = sys.argv[1]
    output_pdf = sys.argv[2]

    if not os.path.exists(header_file):
        print(f"ERROR: File not found → {header_file}")
        sys.exit(1)

    print("Analyzing header...")
    analysis_text = run_analysis(header_file)

    print("Generating PDF...")
    write_pdf(analysis_text, output_pdf)

    print(f"Done! PDF saved → {output_pdf}")
